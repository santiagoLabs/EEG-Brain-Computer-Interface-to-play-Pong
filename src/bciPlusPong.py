from colorama import init, Fore, Back
import pygame as pyg
from pygame import gfxdraw
import sys,os
import random
import time
# import Cortex library developed by me
from cortex import Cortex
import asyncio
import websockets
import warnings
from art import *
import shutil

pyg.init()# PyGame initalization
warnings.filterwarnings("ignore")
clock = pyg.time.Clock()

BLACK = (0,0, 0)		# Set color black in RGB
WHITE = (255, 255, 255) # Set color white in RGB
PINK = (216,27,96) 		# Set color pink in RGB
FPS = 360
init()

screenSize = [1280, 720]# Set Window game size
playerScore = 0
aiScore = 0

# ASCII Menus
art1 = text2art("Lain BCI", font="sub-zero")
art2 = text2art("Connect your brain", font="small")
art3 = text2art("Training", font="sub-zero")

# INSERT CODES GENERATED BY EMOTIV
# First parameter is clientID 
# Second parameter secretID
# Cortex Object initialization. Check Cortex libary I developed for more information
cortex = Cortex("XX", "XX", "wss://localhost:6868")

# Class used to intialiaze font objects. Font object is text that can be displayed on the game
class Font():
	def __init__(self, color, name, size, posX, posY):
		self.font = pyg.font.Font(name, size)
		self.color = color
		self.posX = posX
		self.posY = posY
		self.text = None
		self.rect = None

	def render(self, text):
		self.text = self.font.render(str(text), 1, self.color)
		self.rect = self.text.get_rect(centerx = self.posX, centery = self.posY)


# Superclass
class GameObject():
	def __init__(self, color, width, height, speedY, posX, posY):
		self.color = color
		self.width = width
		self.height = height
		self.speedY = speedY
		self.posX = posX
		self.posY = posY


# Class Paddle represents the game object paddle
class Paddle(GameObject):
	def __init__(self, color, width, height, speedY, posX, posY):
		super().__init__(color, width, height, speedY, posX, posY)
		self.rect = pyg.Rect(posX, posY, width, height)

	# Move the paddle up or down within the boundaries of the window
	def update(self, boundaryX, boundaryY, keyCode):
		if keyCode == 0 and self.rect.top > 0:
			self.rect.y -= self.speedY
		elif keyCode == 1 and self.rect.bottom < boundaryY:
			self.rect.y += self.speedY
		return

	# Manages the movement of the AI. Moves down when the ball is below the top part of the paddle and viceversa
	def updateAi(self, boundaryY, ball):
		if ball.rect.x > 640 and ball.speedX > 0: 
			if ball.rect.y > self.rect.top and self.rect.bottom < boundaryY:
				self.rect.y += self.speedY
			if ball.rect.y < self.rect.bottom and self.rect.top > 0:
				self.rect.y -= self.speedY

		return 

	# Print the paddle on screen
	def draw(self, window, color):
		pyg.draw.rect(window, color, self.rect, 0)
		return

# Class Ball resepresents the game object ball
class Ball(GameObject):
	def __init__(self, color, size, speedX, speedY, posX, posY, sound):
		super().__init__(color, size, size, speedY, posX, posY)
		self.rect = pyg.Rect(posX, posY, size, size)
		self.invisibleRect = pyg.Rect(posX, posY, size, size)
		self.speedX = speedX
		self.sound = sound
		self.playerCollisions = 0

	# Move the ball around
	def update(self, boundaryX, boundaryY, player, ai):
		global playerScore
		global aiScore
		
		if self.rect.x < 0 and self.rect.y < boundaryY:
			aiScore += 1
			self.playerCollisions = 0
			self.reset()
			time.sleep(1)

		# Collision detection BOTTOM of the screen
		elif self.rect.x > 0 and self.rect.bottom >= boundaryY:
			self.speedX *= 1
			self.speedY *= -1

		# Collision  detection TOP of the screen
		elif self.rect.x > 0 and self.rect.y <= 0:
			self.speedX *= 1
			self.speedY *= -1

		# Collision detection RIGHT of the screen
		elif self.rect.right >  boundaryX and self.rect.y < boundaryY:
			playerScore += 1
			ai.speedY = 5
			self.reset()
			time.sleep(1)

		# Collision detection with paddle
		elif self.rect.colliderect(ai): 
			self.speedX = 2
			randY = random.randint(0, 2)
			rand = random.choice((-1, 1))
			self.sound.play()
			self.speedY = randY
			self.speedX *= -1
			self.speedY *= rand


		elif self.rect.colliderect(player):
			self.playerCollisions += 1
			randY = random.randint(1, 2)
			self.speedY = randY
			self.sound.play()
			rand = random.choice((-1, 1))
			self.speedX *= -1
			self.speedY *= rand
		

		# Change position of ball depending on the current speed	
		self.rect.x += self.speedX
		self.rect.y += self.speedY
	
		return

	# Draw ball on screen
	def draw(self, window, color):
		pyg.draw.ellipse(window, color, self.rect, 0)
		return

	# When the one the players score a point, the ball goes to a random direction starting from the center of the window
	def reset(self):
		randY = random.randint(0, 2)
		rand = random.choice((-1, 1))
		self.rect.center = (screenSize[0]/2 -10, screenSize[1]/2 -10)
		
		self.speedY = randY
		self.speedX = 2
		self.speedX *= rand
		self.speedY *= rand
		
		return

	# Called when the player achieves >40% of focus
	def powerUp(self, boundaryX, boundaryY):
		global playerScore 

		if self.rect.right >  boundaryX and self.rect.y < boundaryY:
			playerScore += 1
			return True

		self.rect.x += self.speedX
		self.rect.y += self.speedY

# Class used to create progress bars
class Bar:
	def __init__(self, color, width, height, posX, posY):
		self.rect = pyg.Rect(posX, posY, width, height)
		self.color = color
		self.rect1 = self.rect
		self.size = 0

	def update(self, value):
		if value > self.size:
			self.rect1 = pyg.Rect(self.rect.x, self.rect.y-value*2, 20, value*2)
			self.size = value
		else:
			self.rect1 = pyg.Rect(self.rect.x, self.rect.y-value*2, 20, value*2)
			self.size = value
		return
	
	def draw(self, window):
		pyg.draw.rect(window, PINK, self.rect1, 0)
		return

	def drawOut(self, window):
		pyg.draw.rect(window, WHITE, self.rect, 3)
		return

# Function used to load sound effects
def load_sound(name):
	sound = pyg.mixer.Sound(name)
	return sound

# Print LAIN BCI menu
def printMenu(art1, art2):
	print(Fore.MAGENTA+ art1 +Fore.RESET)
	print(Fore.CYAN + art2 + Fore.RESET)
	print("1) Connect headset to Brain Computer Interface - MUST DO")
	print("2) Check status of headset")
	print("3) Create session - MUST DO before loading traning profile" )
	print("4) Display training profiles available ")
	print("5) Display trainining profile loaded on BCI")
	print("6) Load profile into BCI")
	print("7) Training")
	print("")
	return 

# Print Traininig Menu
def printTrainMenu():
	print(art3)
	print("")
	print("1)Tips for traning:")
	print("2)Create profile")
	print("3)Load profile")
	print("4)Train")
	print("5)Go back to Lain BCI")
	print("")
	return 

# Handles training events sent by Emotiv Corex API to train commands
async def performTraining(profile, mentalCommand):
	global cortex
	# Initialization of training paddle to use as visual aid while training mental commands
	trainPaddle = Paddle(PINK, 20, 150, 20, 8, screenSize[1]/2 - 90)
	trainingScoreFont = Font(PINK, "futura.ttf", 10, screenSize[0]/2, screenSize[1]/2)
	trainingResult = ""
	trainingScore = ""

	# send to cortex the action of starting the training
	await cortex.training("mentalCommand", "start", mentalCommand)
	# Loops until the training is complete and diplay the paddle
	while trainingResult != "MC_Succeeded":
		# Draw on pygame window the paddle 
		trainPaddle.draw(screen, PINK)
		pyg.display.update(trainPaddle)
		screen.blit(backGround, (0,0))
		trainPaddle.rect.y -= 1
		trainPaddle.draw(screen, PINK)
		pyg.display.flip()

		# Receive training event calling the method from Cortex Library developed by me
		trainingResult = await cortex.receiveTrainingData()
		print(trainingResult)
		trainingResult = ""
		screen.blit(backGround, (0,0))
		pyg.display.flip()

		# Get training score achieved on command just trained
		trainingScore = await cortex.mentalCommandTrainingThreshold(profile)
		print(trainingScore["result"]["lastTrainingScore"])
		# ask the user if they want to accept training
		acceptAnswer = input("Do you want to accept the training? Type yes or no: ")
		if acceptAnswer == "yes":
			# save to emotiv profile the training
			await cortex.training("mentalCommand", "accept", mentalCommand)
		elif acceptAnswer == "no":
			#reject trainining
			await cortex.training("mentalCommand", "reject", mentalCommand)
	return


# manage the training phase
async def training(screen, backGround):
	global cortex
	answer = ""
	trainChoice = ""
	adviceFont = Font(PINK, "futura.ttf", 40, screenSize[0]/2, screenSize[1]/2 -20)
	profile = ""
	printTrainMenu()

	# subscribe to data stream of training events such as beggining of training and end of training
	await cortex.subscribe(["sys"])
	while(answer != "5"):
		print("")
		answer = input("Answer: ")
		print("")
		if answer == "1":
			print("You can think of a movement, sound or even food taste. Imagine! But remeber, change type(movement, sound etc.) of though for each command")
		if answer == "2":
			profile = input("Insert name of profile: ")
			await cortex.setupProfile(profile, "create")
			print("Profile created!")
		if answer == "3":
			profile = input("Insert profile you want to load: ")
			await cortex.setupProfile(profile, "load")
			print("Profile loaded")
		
		if answer == "4":

			while trainChoice != "4":
				#print(await cortex.getTrainedSignatureActions("mentalCommand", "Cristo"))
				print("1) Train NEUTRAL command")
				print("2) Train LIFT command")
				print("3) Train DROP command")
				print("4)Go back to Training menu")
				print("")
				choice = input("Answer: ")
				if choice == "1":
					adviceFont.render("FOR 8 SECS LOOK AT THE PADDLE, RELAX AND FREE YOUR MIND!")
					screen.blit(adviceFont.text, adviceFont.rect)
					performTraining(profile, "neutral")
				
				elif choice == "2":
					adviceFont.render("CONSTANTLY RECREATE THE THOUGHT CHOSEN TO TRAIN LIFT")
					screen.blit(adviceFont.text, adviceFont.rect)
					pyg.display.flip()
					performTraining(profile, "lift")

				elif choice == "3":
					adviceFont.render("CONSTANTLY RECREATE THE THOUGHT CHOSEN TO TRAIN DROP")
					screen.blit(adviceFont.text, adviceFont.rect)
					pyg.display.flip()
					performTraining(profile, "drop")

				elif choice == "4":
					os.system("clear")
					printTrainMenu()
					break

		# unsub from the data stream sys so the system can subscribe to another data stream
		if answer == "5":
			await cortex.unsubscribe(["sys"])
			os.system("clear")
			printMenu(art1, art2)
			return 


# Handles lainBCI menu and make the required method calls 
async def lainBCI(screen, backGround):
	answer  = None
	profileLoaded = ""
	profileName = None
	appEx = False

	printMenu(art1, art2)
	while(answer != "0"):

		print("")
		answer = input("Answer (0 to exit): ")
		print("")
		print(Fore.RED)
		# Connects headset to program
		if answer == "1":
			headsetInfo = await cortex.queryHeadsets()
			if cortex.headsetStatus != "connected":
				await cortex.actionOnHeadset("connect")
			print(headsetInfo)

		# Print status of the headset e.g connected, discovered etc.
		elif answer == "2":
			print(cortex.headsetStatus)

		# Create session, so Cortex API can send data
		elif answer == "3":
			await cortex.createSession("open")
			await cortex.updateSession()
			await cortex.querySessions()

		# Get available profiles on Emotiv account
		elif answer == "4":
			print("TRAINING PROFILES:")
			await cortex.queryProfile()

		# Get profile loaded on headset
		elif answer == "5":
			response = await cortex.getCurrentProfile()
			print(response)

		# Load training profile on Headset
		elif answer == "6":
			await cortex.unloadProfile()
			profileName = input("Insert name of profile you want to load: ")
			await cortex.setupProfile(profileName, "load")
			response = await cortex.getCurrentProfile()
			profileLoaded = response["result"]["name"]
			appEx = response["result"]["loadedByThisApp"]

		# Goes to traning menu
		elif answer == "7":
			os.system("clear")
			await training(screen, backGround)

		if cortex.sessionId != None and cortex.headsetStatus == "connected" and profileLoaded == profileName and appEx == True: 
			print("YOU'RE ALL SET! YOU CAN START PLAYING!")
		print(Fore.RESET)
	return


async def main():
	global playerScore
	global aiScore
	mentalCommand = ""

	# Initialization of game window, it return a Surface object
	screen = pyg.display.set_mode((screenSize[0], screenSize[1]))
	# Set the caption of the window
	pyg.display.set_caption("Pong")
	#screen.fill(BLACK)
	gameLoop = True
	# Initialization of the game window background
	backGround = pyg.Surface((screen.get_width(), screen.get_height()))
	backGround.fill(BLACK)
	backGround2 = backGround
	focusPowerUp = 0

	# load the sound effect for the bouncing ball
	ballSound = load_sound("hit.wav")

	# Send authorization request to Cortex API
	await cortex.requestAccess()
	await cortex.getAuthorizationToken()

	await lainBCI(screen, backGround)
	asyncio.sleep(3)
	os.system("clear")

	# Create object font to print the score on screen with parameters: color, name, size, posX, posY
	playerFont = Font(PINK, "futura.ttf", 25, screenSize[0]/2 - 20, screenSize[1]/2)
	playerFont.render(playerScore)
	screen.blit(playerFont.text, playerFont.rect)

	aiFont = Font(PINK, "futura.ttf", 25, screenSize[0]/2 + 20, screenSize[1]/2)
	aiFont.render(aiScore)
	screen.blit(aiFont.text, aiFont.rect)

	barFont = Font(PINK, "futura.ttf", 20, 210, 230)
	collisionPowerUpFont = Font(PINK, "futura.ttf", 25, 200, 180)
	winnerFont = Font(PINK, "futura.ttf", 30, screenSize[0]/2, screenSize[1]/2)

	focusFont = Font(PINK, "futura.ttf", 15, 210, 430)
	
	# Draw a line at the center of the window
	pyg.draw.aaline(screen, PINK, (screenSize[0]/2, 0), (screenSize[0]/2, screenSize[1]))
	# Update the game window so that the drawn element can be visible
	pyg.display.flip()

	# Create object player with parameters: Color, width, height, speedY, posX, posY
	player = Paddle(PINK, 25, 220, 8, 8, screenSize[1]/2 - 140)
	player.draw(screen, PINK)
	pyg.display.update(player)
	backSound = load_sound("worming.wav")
	ai = Paddle(PINK, 25, 220, 6, screenSize[0]-28, screenSize[1]/2 - 90)
	ai.draw(screen, PINK)
	pyg.display.update(ai)
	# Create object ball with parameters: Color, size, speedX, speedY
	ball = Ball(PINK, 20, 2, 0, screenSize[0]/2-10, screenSize[1]/2 -10, ballSound)
	ball.draw(screen, PINK)
	pyg.display.update(ball)

	# Create progress bar for displaying level of focus
	focusBar = Bar(PINK, 20, 0, 200, 400)
	outlineBar = Bar(WHITE, 20, 200, 200, 200)
	powerUP = False


 	#Subscribe to mental commands and performane metrics data stream
	result = await cortex.subscribe(["com","met"])
	print(result)
	focusValue = 0
	while gameLoop:

		# stores in variable the mental commands received through the web socket and level of focus
		data = await cortex.receiveData()
		if len(data) > 0:
			if "met" in data:
				if data["met"][12] != None:
					focusValue =  int(data["met"][12]*100)
					print(str(focusValue))
			else:
				mentalCommand = data["com"][0]
				print(mentalCommand)


		clock.tick(FPS)
		# Checks which player won and prints on screen the winner and restarts the game
		if playerScore == 5 or aiScore == 5:
			backSound.play()
			screen.blit(backGround2, (0,0))
			if playerScore > aiScore:
				winnerFont.render("PLAYER 1 WON! YOU'RE A BEAST!")
				screen.blit(winnerFont.text, winnerFont.rect)
				pyg.display.update()
			else:
				winnerFont.render("AI WON! HUMANS YOUR END IS NEAR")
				screen.blit(winnerFont.text, winnerFont.rect)
				pyg.display.update()

			playerScore = 0
			aiScore = 0
			asyncio.sleep(5)
			backSound.stop()
			
		else:
		
			for event in pyg.event.get():
				if event.type == pyg.QUIT:
					pyg.quit()
					cortex.close()
					sys.exit()


			# Mental commands are used to control the movement of the paddle
			if mentalCommand == "lift":
				player.update(0, screenSize[1], 0)
			elif mentalCommand == "drop":
				player.update(0, screenSize[1], 1)

		

			# Print the game elemetns on screen at each frame

			screen.blit(backGround, (0,0))
			playerFont.render(playerScore)
			aiFont.render(aiScore)
			screen.blit(playerFont.text, playerFont.rect)
			screen.blit(aiFont.text, aiFont.rect)

			pyg.draw.aaline(screen, PINK, (screenSize[0]/2, 0), (screenSize[0]/2, screenSize[1]))
			player.draw(screen, PINK)
			ball.update(screenSize[0], screenSize[1], player, ai)
			ball.draw(screen, PINK)

			ai.updateAi(screenSize[1], ball)
			ai.draw(screen, PINK)

			# Check if there are the right conditions to unlock the power-up
			if ball.playerCollisions > 2:
				# diplay the progress bar and focus value
				collisionPowerUpFont.render("POWERUP, FOCUS!")
				screen.blit(collisionPowerUpFont.text, collisionPowerUpFont.rect)
				focusFont.render(focusValue)
				screen.blit(focusFont.text,focusFont.rect)
				focusBar.update(focusValue)
				focusBar.draw(screen)
				outlineBar.drawOut(screen)
				pyg.draw.line(screen, WHITE, (200,320), (220, 320), 3)
				# When the ball is coming back to the player check if the level of focus is more than 40
				if ball.rect.x < 80 and ball.speedX < 0:
					ball.playerCollisions = 0
					if focusValue > 40:
						ball.speedX -= 20
						ai.speedY = 0
						focusValue = 0


			pyg.display.update()
			
	deinit()
	cortex.close()
	pyg.quit()

asyncio.get_event_loop().run_until_complete(main())